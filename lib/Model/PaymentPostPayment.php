<?php
/**
 * PaymentPostPayment
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * API Pagos Instantáneos
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v3.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.10.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * PaymentPostPayment Class Doc Comment
 *
 * @category Class
 * @description Crea un pago en Khipu y obtiene las URLs para redirección al usuario para que complete el pago.
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class PaymentPostPayment implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'payment-post-payment';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'amount' => 'float',
        'currency' => 'string',
        'subject' => 'string',
        'transaction_id' => 'string',
        'custom' => 'string',
        'body' => 'string',
        'bank_id' => 'string',
        'return_url' => 'string',
        'cancel_url' => 'string',
        'picture_url' => 'string',
        'notify_url' => 'string',
        'contract_url' => 'string',
        'notify_api_version' => 'string',
        'expires_date' => '\DateTime',
        'send_email' => 'bool',
        'payer_name' => 'string',
        'payer_email' => 'string',
        'send_reminders' => 'bool',
        'responsible_user_email' => 'string',
        'fixed_payer_personal_identifier' => 'string',
        'integrator_fee' => 'string',
        'collect_account_uuid' => 'string',
        'confirm_timeout_date' => '\DateTime',
        'mandatory_payment_method' => 'string',
        'psp_client_merchant_name' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'amount' => 'double',
        'currency' => null,
        'subject' => null,
        'transaction_id' => null,
        'custom' => null,
        'body' => null,
        'bank_id' => null,
        'return_url' => null,
        'cancel_url' => null,
        'picture_url' => null,
        'notify_url' => null,
        'contract_url' => null,
        'notify_api_version' => null,
        'expires_date' => 'date-time',
        'send_email' => null,
        'payer_name' => null,
        'payer_email' => 'email',
        'send_reminders' => null,
        'responsible_user_email' => 'email',
        'fixed_payer_personal_identifier' => null,
        'integrator_fee' => null,
        'collect_account_uuid' => null,
        'confirm_timeout_date' => 'date-time',
        'mandatory_payment_method' => null,
        'psp_client_merchant_name' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'amount' => false,
        'currency' => false,
        'subject' => false,
        'transaction_id' => false,
        'custom' => false,
        'body' => false,
        'bank_id' => false,
        'return_url' => false,
        'cancel_url' => false,
        'picture_url' => false,
        'notify_url' => false,
        'contract_url' => false,
        'notify_api_version' => false,
        'expires_date' => false,
        'send_email' => false,
        'payer_name' => false,
        'payer_email' => false,
        'send_reminders' => false,
        'responsible_user_email' => false,
        'fixed_payer_personal_identifier' => false,
        'integrator_fee' => false,
        'collect_account_uuid' => false,
        'confirm_timeout_date' => false,
        'mandatory_payment_method' => false,
        'psp_client_merchant_name' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'amount' => 'amount',
        'currency' => 'currency',
        'subject' => 'subject',
        'transaction_id' => 'transaction_id',
        'custom' => 'custom',
        'body' => 'body',
        'bank_id' => 'bank_id',
        'return_url' => 'return_url',
        'cancel_url' => 'cancel_url',
        'picture_url' => 'picture_url',
        'notify_url' => 'notify_url',
        'contract_url' => 'contract_url',
        'notify_api_version' => 'notify_api_version',
        'expires_date' => 'expires_date',
        'send_email' => 'send_email',
        'payer_name' => 'payer_name',
        'payer_email' => 'payer_email',
        'send_reminders' => 'send_reminders',
        'responsible_user_email' => 'responsible_user_email',
        'fixed_payer_personal_identifier' => 'fixed_payer_personal_identifier',
        'integrator_fee' => 'integrator_fee',
        'collect_account_uuid' => 'collect_account_uuid',
        'confirm_timeout_date' => 'confirm_timeout_date',
        'mandatory_payment_method' => 'mandatory_payment_method',
        'psp_client_merchant_name' => 'psp_client_merchant_name'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'amount' => 'setAmount',
        'currency' => 'setCurrency',
        'subject' => 'setSubject',
        'transaction_id' => 'setTransactionId',
        'custom' => 'setCustom',
        'body' => 'setBody',
        'bank_id' => 'setBankId',
        'return_url' => 'setReturnUrl',
        'cancel_url' => 'setCancelUrl',
        'picture_url' => 'setPictureUrl',
        'notify_url' => 'setNotifyUrl',
        'contract_url' => 'setContractUrl',
        'notify_api_version' => 'setNotifyApiVersion',
        'expires_date' => 'setExpiresDate',
        'send_email' => 'setSendEmail',
        'payer_name' => 'setPayerName',
        'payer_email' => 'setPayerEmail',
        'send_reminders' => 'setSendReminders',
        'responsible_user_email' => 'setResponsibleUserEmail',
        'fixed_payer_personal_identifier' => 'setFixedPayerPersonalIdentifier',
        'integrator_fee' => 'setIntegratorFee',
        'collect_account_uuid' => 'setCollectAccountUuid',
        'confirm_timeout_date' => 'setConfirmTimeoutDate',
        'mandatory_payment_method' => 'setMandatoryPaymentMethod',
        'psp_client_merchant_name' => 'setPspClientMerchantName'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'amount' => 'getAmount',
        'currency' => 'getCurrency',
        'subject' => 'getSubject',
        'transaction_id' => 'getTransactionId',
        'custom' => 'getCustom',
        'body' => 'getBody',
        'bank_id' => 'getBankId',
        'return_url' => 'getReturnUrl',
        'cancel_url' => 'getCancelUrl',
        'picture_url' => 'getPictureUrl',
        'notify_url' => 'getNotifyUrl',
        'contract_url' => 'getContractUrl',
        'notify_api_version' => 'getNotifyApiVersion',
        'expires_date' => 'getExpiresDate',
        'send_email' => 'getSendEmail',
        'payer_name' => 'getPayerName',
        'payer_email' => 'getPayerEmail',
        'send_reminders' => 'getSendReminders',
        'responsible_user_email' => 'getResponsibleUserEmail',
        'fixed_payer_personal_identifier' => 'getFixedPayerPersonalIdentifier',
        'integrator_fee' => 'getIntegratorFee',
        'collect_account_uuid' => 'getCollectAccountUuid',
        'confirm_timeout_date' => 'getConfirmTimeoutDate',
        'mandatory_payment_method' => 'getMandatoryPaymentMethod',
        'psp_client_merchant_name' => 'getPspClientMerchantName'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const CURRENCY_CLP = 'CLP';
    public const CURRENCY_CLF = 'CLF';
    public const CURRENCY_ARS = 'ARS';
    public const CURRENCY_PEN = 'PEN';
    public const CURRENCY_MXN = 'MXN';
    public const CURRENCY_USD = 'USD';
    public const CURRENCY_EUR = 'EUR';
    public const CURRENCY_BOB = 'BOB';
    public const CURRENCY_COP = 'COP';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCurrencyAllowableValues()
    {
        return [
            self::CURRENCY_CLP,
            self::CURRENCY_CLF,
            self::CURRENCY_ARS,
            self::CURRENCY_PEN,
            self::CURRENCY_MXN,
            self::CURRENCY_USD,
            self::CURRENCY_EUR,
            self::CURRENCY_BOB,
            self::CURRENCY_COP,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('amount', $data ?? [], null);
        $this->setIfExists('currency', $data ?? [], null);
        $this->setIfExists('subject', $data ?? [], null);
        $this->setIfExists('transaction_id', $data ?? [], null);
        $this->setIfExists('custom', $data ?? [], null);
        $this->setIfExists('body', $data ?? [], null);
        $this->setIfExists('bank_id', $data ?? [], null);
        $this->setIfExists('return_url', $data ?? [], null);
        $this->setIfExists('cancel_url', $data ?? [], null);
        $this->setIfExists('picture_url', $data ?? [], null);
        $this->setIfExists('notify_url', $data ?? [], null);
        $this->setIfExists('contract_url', $data ?? [], null);
        $this->setIfExists('notify_api_version', $data ?? [], null);
        $this->setIfExists('expires_date', $data ?? [], null);
        $this->setIfExists('send_email', $data ?? [], null);
        $this->setIfExists('payer_name', $data ?? [], null);
        $this->setIfExists('payer_email', $data ?? [], null);
        $this->setIfExists('send_reminders', $data ?? [], null);
        $this->setIfExists('responsible_user_email', $data ?? [], null);
        $this->setIfExists('fixed_payer_personal_identifier', $data ?? [], null);
        $this->setIfExists('integrator_fee', $data ?? [], null);
        $this->setIfExists('collect_account_uuid', $data ?? [], null);
        $this->setIfExists('confirm_timeout_date', $data ?? [], null);
        $this->setIfExists('mandatory_payment_method', $data ?? [], null);
        $this->setIfExists('psp_client_merchant_name', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['amount'] === null) {
            $invalidProperties[] = "'amount' can't be null";
        }
        if ($this->container['currency'] === null) {
            $invalidProperties[] = "'currency' can't be null";
        }
        $allowedValues = $this->getCurrencyAllowableValues();
        if (!is_null($this->container['currency']) && !in_array($this->container['currency'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'currency', must be one of '%s'",
                $this->container['currency'],
                implode("', '", $allowedValues)
            );
        }

        if ((mb_strlen($this->container['currency']) > 255)) {
            $invalidProperties[] = "invalid value for 'currency', the character length must be smaller than or equal to 255.";
        }

        if ($this->container['subject'] === null) {
            $invalidProperties[] = "'subject' can't be null";
        }
        if ((mb_strlen($this->container['subject']) > 255)) {
            $invalidProperties[] = "invalid value for 'subject', the character length must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['transaction_id']) && (mb_strlen($this->container['transaction_id']) > 255)) {
            $invalidProperties[] = "invalid value for 'transaction_id', the character length must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['custom']) && (mb_strlen($this->container['custom']) > 1073741824)) {
            $invalidProperties[] = "invalid value for 'custom', the character length must be smaller than or equal to 1073741824.";
        }

        if (!is_null($this->container['body']) && (mb_strlen($this->container['body']) > 5120)) {
            $invalidProperties[] = "invalid value for 'body', the character length must be smaller than or equal to 5120.";
        }

        if (!is_null($this->container['bank_id']) && (mb_strlen($this->container['bank_id']) > 5)) {
            $invalidProperties[] = "invalid value for 'bank_id', the character length must be smaller than or equal to 5.";
        }

        if (!is_null($this->container['return_url']) && (mb_strlen($this->container['return_url']) > 1024)) {
            $invalidProperties[] = "invalid value for 'return_url', the character length must be smaller than or equal to 1024.";
        }

        if (!is_null($this->container['cancel_url']) && (mb_strlen($this->container['cancel_url']) > 1024)) {
            $invalidProperties[] = "invalid value for 'cancel_url', the character length must be smaller than or equal to 1024.";
        }

        if (!is_null($this->container['picture_url']) && (mb_strlen($this->container['picture_url']) > 1024)) {
            $invalidProperties[] = "invalid value for 'picture_url', the character length must be smaller than or equal to 1024.";
        }

        if (!is_null($this->container['notify_url']) && (mb_strlen($this->container['notify_url']) > 1024)) {
            $invalidProperties[] = "invalid value for 'notify_url', the character length must be smaller than or equal to 1024.";
        }

        if (!is_null($this->container['contract_url']) && (mb_strlen($this->container['contract_url']) > 1024)) {
            $invalidProperties[] = "invalid value for 'contract_url', the character length must be smaller than or equal to 1024.";
        }

        if (!is_null($this->container['notify_api_version']) && (mb_strlen($this->container['notify_api_version']) > 255)) {
            $invalidProperties[] = "invalid value for 'notify_api_version', the character length must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['payer_name']) && (mb_strlen($this->container['payer_name']) > 255)) {
            $invalidProperties[] = "invalid value for 'payer_name', the character length must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['payer_email']) && (mb_strlen($this->container['payer_email']) > 255)) {
            $invalidProperties[] = "invalid value for 'payer_email', the character length must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['responsible_user_email']) && (mb_strlen($this->container['responsible_user_email']) > 255)) {
            $invalidProperties[] = "invalid value for 'responsible_user_email', the character length must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['fixed_payer_personal_identifier']) && (mb_strlen($this->container['fixed_payer_personal_identifier']) > 255)) {
            $invalidProperties[] = "invalid value for 'fixed_payer_personal_identifier', the character length must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['integrator_fee']) && (mb_strlen($this->container['integrator_fee']) > 16)) {
            $invalidProperties[] = "invalid value for 'integrator_fee', the character length must be smaller than or equal to 16.";
        }

        if (!is_null($this->container['collect_account_uuid']) && (mb_strlen($this->container['collect_account_uuid']) > 255)) {
            $invalidProperties[] = "invalid value for 'collect_account_uuid', the character length must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['mandatory_payment_method']) && (mb_strlen($this->container['mandatory_payment_method']) > 255)) {
            $invalidProperties[] = "invalid value for 'mandatory_payment_method', the character length must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['psp_client_merchant_name']) && (mb_strlen($this->container['psp_client_merchant_name']) > 255)) {
            $invalidProperties[] = "invalid value for 'psp_client_merchant_name', the character length must be smaller than or equal to 255.";
        }

        if (!is_null($this->container['psp_client_merchant_name']) && (mb_strlen($this->container['psp_client_merchant_name']) < 3)) {
            $invalidProperties[] = "invalid value for 'psp_client_merchant_name', the character length must be bigger than or equal to 3.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets amount
     *
     * @return float
     */
    public function getAmount()
    {
        return $this->container['amount'];
    }

    /**
     * Sets amount
     *
     * @param float $amount El monto del cobro. Sin separador de miles y usando '.' como separador de decimales. Hasta 4 lugares decimales, dependiendo de la moneda.
     *
     * @return self
     */
    public function setAmount($amount)
    {
        if (is_null($amount)) {
            throw new \InvalidArgumentException('non-nullable amount cannot be null');
        }
        $this->container['amount'] = $amount;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string $currency El código de moneda en formato ISO-4217.
     *
     * @return self
     */
    public function setCurrency($currency)
    {
        if (is_null($currency)) {
            throw new \InvalidArgumentException('non-nullable currency cannot be null');
        }
        $allowedValues = $this->getCurrencyAllowableValues();
        if (!in_array($currency, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'currency', must be one of '%s'",
                    $currency,
                    implode("', '", $allowedValues)
                )
            );
        }
        if ((mb_strlen($currency) > 255)) {
            throw new \InvalidArgumentException('invalid length for $currency when calling PaymentPostPayment., must be smaller than or equal to 255.');
        }

        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets subject
     *
     * @return string
     */
    public function getSubject()
    {
        return $this->container['subject'];
    }

    /**
     * Sets subject
     *
     * @param string $subject Motivo.
     *
     * @return self
     */
    public function setSubject($subject)
    {
        if (is_null($subject)) {
            throw new \InvalidArgumentException('non-nullable subject cannot be null');
        }
        if ((mb_strlen($subject) > 255)) {
            throw new \InvalidArgumentException('invalid length for $subject when calling PaymentPostPayment., must be smaller than or equal to 255.');
        }

        $this->container['subject'] = $subject;

        return $this;
    }

    /**
     * Gets transaction_id
     *
     * @return string|null
     */
    public function getTransactionId()
    {
        return $this->container['transaction_id'];
    }

    /**
     * Sets transaction_id
     *
     * @param string|null $transaction_id Identificador propio de la transacción. Ej: número de factura u orden de compra.
     *
     * @return self
     */
    public function setTransactionId($transaction_id)
    {
        if (is_null($transaction_id)) {
            throw new \InvalidArgumentException('non-nullable transaction_id cannot be null');
        }
        if ((mb_strlen($transaction_id) > 255)) {
            throw new \InvalidArgumentException('invalid length for $transaction_id when calling PaymentPostPayment., must be smaller than or equal to 255.');
        }

        $this->container['transaction_id'] = $transaction_id;

        return $this;
    }

    /**
     * Gets custom
     *
     * @return string|null
     */
    public function getCustom()
    {
        return $this->container['custom'];
    }

    /**
     * Sets custom
     *
     * @param string|null $custom Parámetro para enviar información personalizada de la transacción. Ej: documento XML con el detalle del carro de compra.
     *
     * @return self
     */
    public function setCustom($custom)
    {
        if (is_null($custom)) {
            throw new \InvalidArgumentException('non-nullable custom cannot be null');
        }
        if ((mb_strlen($custom) > 1073741824)) {
            throw new \InvalidArgumentException('invalid length for $custom when calling PaymentPostPayment., must be smaller than or equal to 1073741824.');
        }

        $this->container['custom'] = $custom;

        return $this;
    }

    /**
     * Gets body
     *
     * @return string|null
     */
    public function getBody()
    {
        return $this->container['body'];
    }

    /**
     * Sets body
     *
     * @param string|null $body Descripción del cobro.
     *
     * @return self
     */
    public function setBody($body)
    {
        if (is_null($body)) {
            throw new \InvalidArgumentException('non-nullable body cannot be null');
        }
        if ((mb_strlen($body) > 5120)) {
            throw new \InvalidArgumentException('invalid length for $body when calling PaymentPostPayment., must be smaller than or equal to 5120.');
        }

        $this->container['body'] = $body;

        return $this;
    }

    /**
     * Gets bank_id
     *
     * @return string|null
     */
    public function getBankId()
    {
        return $this->container['bank_id'];
    }

    /**
     * Sets bank_id
     *
     * @param string|null $bank_id Identificador del banco para usar en el pago.
     *
     * @return self
     */
    public function setBankId($bank_id)
    {
        if (is_null($bank_id)) {
            throw new \InvalidArgumentException('non-nullable bank_id cannot be null');
        }
        if ((mb_strlen($bank_id) > 5)) {
            throw new \InvalidArgumentException('invalid length for $bank_id when calling PaymentPostPayment., must be smaller than or equal to 5.');
        }

        $this->container['bank_id'] = $bank_id;

        return $this;
    }

    /**
     * Gets return_url
     *
     * @return string|null
     */
    public function getReturnUrl()
    {
        return $this->container['return_url'];
    }

    /**
     * Sets return_url
     *
     * @param string|null $return_url La dirección URL a donde enviar al cliente mientras el pago está siendo verificado.
     *
     * @return self
     */
    public function setReturnUrl($return_url)
    {
        if (is_null($return_url)) {
            throw new \InvalidArgumentException('non-nullable return_url cannot be null');
        }
        if ((mb_strlen($return_url) > 1024)) {
            throw new \InvalidArgumentException('invalid length for $return_url when calling PaymentPostPayment., must be smaller than or equal to 1024.');
        }

        $this->container['return_url'] = $return_url;

        return $this;
    }

    /**
     * Gets cancel_url
     *
     * @return string|null
     */
    public function getCancelUrl()
    {
        return $this->container['cancel_url'];
    }

    /**
     * Sets cancel_url
     *
     * @param string|null $cancel_url La dirección URL a donde enviar al cliente si decide no hacer hacer la transacción.
     *
     * @return self
     */
    public function setCancelUrl($cancel_url)
    {
        if (is_null($cancel_url)) {
            throw new \InvalidArgumentException('non-nullable cancel_url cannot be null');
        }
        if ((mb_strlen($cancel_url) > 1024)) {
            throw new \InvalidArgumentException('invalid length for $cancel_url when calling PaymentPostPayment., must be smaller than or equal to 1024.');
        }

        $this->container['cancel_url'] = $cancel_url;

        return $this;
    }

    /**
     * Gets picture_url
     *
     * @return string|null
     */
    public function getPictureUrl()
    {
        return $this->container['picture_url'];
    }

    /**
     * Sets picture_url
     *
     * @param string|null $picture_url Una dirección URL de una foto de tu producto o servicio.
     *
     * @return self
     */
    public function setPictureUrl($picture_url)
    {
        if (is_null($picture_url)) {
            throw new \InvalidArgumentException('non-nullable picture_url cannot be null');
        }
        if ((mb_strlen($picture_url) > 1024)) {
            throw new \InvalidArgumentException('invalid length for $picture_url when calling PaymentPostPayment., must be smaller than or equal to 1024.');
        }

        $this->container['picture_url'] = $picture_url;

        return $this;
    }

    /**
     * Gets notify_url
     *
     * @return string|null
     */
    public function getNotifyUrl()
    {
        return $this->container['notify_url'];
    }

    /**
     * Sets notify_url
     *
     * @param string|null $notify_url La dirección del web-service que utilizará khipu para notificar cuando el pago esté conciliado.
     *
     * @return self
     */
    public function setNotifyUrl($notify_url)
    {
        if (is_null($notify_url)) {
            throw new \InvalidArgumentException('non-nullable notify_url cannot be null');
        }
        if ((mb_strlen($notify_url) > 1024)) {
            throw new \InvalidArgumentException('invalid length for $notify_url when calling PaymentPostPayment., must be smaller than or equal to 1024.');
        }

        $this->container['notify_url'] = $notify_url;

        return $this;
    }

    /**
     * Gets contract_url
     *
     * @return string|null
     */
    public function getContractUrl()
    {
        return $this->container['contract_url'];
    }

    /**
     * Sets contract_url
     *
     * @param string|null $contract_url La dirección URL del archivo PDF con el contrato a firmar mediante este pago. El cobrador debe estar habilitado para este servicio y el campo `fixed_payer_personal_identifier` es obligatorio.
     *
     * @return self
     */
    public function setContractUrl($contract_url)
    {
        if (is_null($contract_url)) {
            throw new \InvalidArgumentException('non-nullable contract_url cannot be null');
        }
        if ((mb_strlen($contract_url) > 1024)) {
            throw new \InvalidArgumentException('invalid length for $contract_url when calling PaymentPostPayment., must be smaller than or equal to 1024.');
        }

        $this->container['contract_url'] = $contract_url;

        return $this;
    }

    /**
     * Gets notify_api_version
     *
     * @return string|null
     */
    public function getNotifyApiVersion()
    {
        return $this->container['notify_api_version'];
    }

    /**
     * Sets notify_api_version
     *
     * @param string|null $notify_api_version Versión de la API de notificaciones para recibir avisos por web-service.
     *
     * @return self
     */
    public function setNotifyApiVersion($notify_api_version)
    {
        if (is_null($notify_api_version)) {
            throw new \InvalidArgumentException('non-nullable notify_api_version cannot be null');
        }
        if ((mb_strlen($notify_api_version) > 255)) {
            throw new \InvalidArgumentException('invalid length for $notify_api_version when calling PaymentPostPayment., must be smaller than or equal to 255.');
        }

        $this->container['notify_api_version'] = $notify_api_version;

        return $this;
    }

    /**
     * Gets expires_date
     *
     * @return \DateTime|null
     */
    public function getExpiresDate()
    {
        return $this->container['expires_date'];
    }

    /**
     * Sets expires_date
     *
     * @param \DateTime|null $expires_date Fecha máxima para ejecutar el pago (en formato ISO-8601). El cliente podrá realizar varios intentos de pago hasta dicha fecha. Cada intento tiene un plazo individual de 3 horas para su ejecución.
     *
     * @return self
     */
    public function setExpiresDate($expires_date)
    {
        if (is_null($expires_date)) {
            throw new \InvalidArgumentException('non-nullable expires_date cannot be null');
        }
        $this->container['expires_date'] = $expires_date;

        return $this;
    }

    /**
     * Gets send_email
     *
     * @return bool|null
     */
    public function getSendEmail()
    {
        return $this->container['send_email'];
    }

    /**
     * Sets send_email
     *
     * @param bool|null $send_email Si es `true`, se enviará una solicitud de cobro al correo especificado en `payer_email`.
     *
     * @return self
     */
    public function setSendEmail($send_email)
    {
        if (is_null($send_email)) {
            throw new \InvalidArgumentException('non-nullable send_email cannot be null');
        }
        $this->container['send_email'] = $send_email;

        return $this;
    }

    /**
     * Gets payer_name
     *
     * @return string|null
     */
    public function getPayerName()
    {
        return $this->container['payer_name'];
    }

    /**
     * Sets payer_name
     *
     * @param string|null $payer_name Nombre del pagador. Es obligatorio cuando `send_email` es `true`.
     *
     * @return self
     */
    public function setPayerName($payer_name)
    {
        if (is_null($payer_name)) {
            throw new \InvalidArgumentException('non-nullable payer_name cannot be null');
        }
        if ((mb_strlen($payer_name) > 255)) {
            throw new \InvalidArgumentException('invalid length for $payer_name when calling PaymentPostPayment., must be smaller than or equal to 255.');
        }

        $this->container['payer_name'] = $payer_name;

        return $this;
    }

    /**
     * Gets payer_email
     *
     * @return string|null
     */
    public function getPayerEmail()
    {
        return $this->container['payer_email'];
    }

    /**
     * Sets payer_email
     *
     * @param string|null $payer_email Correo del pagador. Es obligatorio cuando `send_email` es `true`.
     *
     * @return self
     */
    public function setPayerEmail($payer_email)
    {
        if (is_null($payer_email)) {
            throw new \InvalidArgumentException('non-nullable payer_email cannot be null');
        }
        if ((mb_strlen($payer_email) > 255)) {
            throw new \InvalidArgumentException('invalid length for $payer_email when calling PaymentPostPayment., must be smaller than or equal to 255.');
        }

        $this->container['payer_email'] = $payer_email;

        return $this;
    }

    /**
     * Gets send_reminders
     *
     * @return bool|null
     */
    public function getSendReminders()
    {
        return $this->container['send_reminders'];
    }

    /**
     * Sets send_reminders
     *
     * @param bool|null $send_reminders Si es `true`, se enviarán recordatorios de cobro.
     *
     * @return self
     */
    public function setSendReminders($send_reminders)
    {
        if (is_null($send_reminders)) {
            throw new \InvalidArgumentException('non-nullable send_reminders cannot be null');
        }
        $this->container['send_reminders'] = $send_reminders;

        return $this;
    }

    /**
     * Gets responsible_user_email
     *
     * @return string|null
     */
    public function getResponsibleUserEmail()
    {
        return $this->container['responsible_user_email'];
    }

    /**
     * Sets responsible_user_email
     *
     * @param string|null $responsible_user_email Correo electrónico del responsable de este cobro, debe corresponder a un usuario Khipu con permisos para cobrar usando esta cuenta de cobro.
     *
     * @return self
     */
    public function setResponsibleUserEmail($responsible_user_email)
    {
        if (is_null($responsible_user_email)) {
            throw new \InvalidArgumentException('non-nullable responsible_user_email cannot be null');
        }
        if ((mb_strlen($responsible_user_email) > 255)) {
            throw new \InvalidArgumentException('invalid length for $responsible_user_email when calling PaymentPostPayment., must be smaller than or equal to 255.');
        }

        $this->container['responsible_user_email'] = $responsible_user_email;

        return $this;
    }

    /**
     * Gets fixed_payer_personal_identifier
     *
     * @return string|null
     */
    public function getFixedPayerPersonalIdentifier()
    {
        return $this->container['fixed_payer_personal_identifier'];
    }

    /**
     * Sets fixed_payer_personal_identifier
     *
     * @param string|null $fixed_payer_personal_identifier Identificador personal. Si se especifica, solo podrá ser pagado usando ese identificador.
     *
     * @return self
     */
    public function setFixedPayerPersonalIdentifier($fixed_payer_personal_identifier)
    {
        if (is_null($fixed_payer_personal_identifier)) {
            throw new \InvalidArgumentException('non-nullable fixed_payer_personal_identifier cannot be null');
        }
        if ((mb_strlen($fixed_payer_personal_identifier) > 255)) {
            throw new \InvalidArgumentException('invalid length for $fixed_payer_personal_identifier when calling PaymentPostPayment., must be smaller than or equal to 255.');
        }

        $this->container['fixed_payer_personal_identifier'] = $fixed_payer_personal_identifier;

        return $this;
    }

    /**
     * Gets integrator_fee
     *
     * @return string|null
     */
    public function getIntegratorFee()
    {
        return $this->container['integrator_fee'];
    }

    /**
     * Sets integrator_fee
     *
     * @param string|null $integrator_fee Comisión para el integrador. Sólo es válido si la cuenta de cobro tiene una cuenta de integrador asociada.
     *
     * @return self
     */
    public function setIntegratorFee($integrator_fee)
    {
        if (is_null($integrator_fee)) {
            throw new \InvalidArgumentException('non-nullable integrator_fee cannot be null');
        }
        if ((mb_strlen($integrator_fee) > 16)) {
            throw new \InvalidArgumentException('invalid length for $integrator_fee when calling PaymentPostPayment., must be smaller than or equal to 16.');
        }

        $this->container['integrator_fee'] = $integrator_fee;

        return $this;
    }

    /**
     * Gets collect_account_uuid
     *
     * @return string|null
     */
    public function getCollectAccountUuid()
    {
        return $this->container['collect_account_uuid'];
    }

    /**
     * Sets collect_account_uuid
     *
     * @param string|null $collect_account_uuid Para cuentas de cobro con más cuenta propia. Permite elegir la cuenta donde debe ocurrir la transferencia.
     *
     * @return self
     */
    public function setCollectAccountUuid($collect_account_uuid)
    {
        if (is_null($collect_account_uuid)) {
            throw new \InvalidArgumentException('non-nullable collect_account_uuid cannot be null');
        }
        if ((mb_strlen($collect_account_uuid) > 255)) {
            throw new \InvalidArgumentException('invalid length for $collect_account_uuid when calling PaymentPostPayment., must be smaller than or equal to 255.');
        }

        $this->container['collect_account_uuid'] = $collect_account_uuid;

        return $this;
    }

    /**
     * Gets confirm_timeout_date
     *
     * @return \DateTime|null
     */
    public function getConfirmTimeoutDate()
    {
        return $this->container['confirm_timeout_date'];
    }

    /**
     * Sets confirm_timeout_date
     *
     * @param \DateTime|null $confirm_timeout_date Fecha de rendición del cobro. Es también la fecha final para poder reembolsar el cobro. Formato ISO-8601.
     *
     * @return self
     */
    public function setConfirmTimeoutDate($confirm_timeout_date)
    {
        if (is_null($confirm_timeout_date)) {
            throw new \InvalidArgumentException('non-nullable confirm_timeout_date cannot be null');
        }
        $this->container['confirm_timeout_date'] = $confirm_timeout_date;

        return $this;
    }

    /**
     * Gets mandatory_payment_method
     *
     * @return string|null
     */
    public function getMandatoryPaymentMethod()
    {
        return $this->container['mandatory_payment_method'];
    }

    /**
     * Sets mandatory_payment_method
     *
     * @param string|null $mandatory_payment_method El cobro sólo se podrá pagar utilizando el medio de pago especificado. Los posibles valores para este campo se encuentran en el campo `id` de la respuesta del endpoint `/api/3.0/merchants/paymentMethods`.
     *
     * @return self
     */
    public function setMandatoryPaymentMethod($mandatory_payment_method)
    {
        if (is_null($mandatory_payment_method)) {
            throw new \InvalidArgumentException('non-nullable mandatory_payment_method cannot be null');
        }
        if ((mb_strlen($mandatory_payment_method) > 255)) {
            throw new \InvalidArgumentException('invalid length for $mandatory_payment_method when calling PaymentPostPayment., must be smaller than or equal to 255.');
        }

        $this->container['mandatory_payment_method'] = $mandatory_payment_method;

        return $this;
    }

    /**
     * Gets psp_client_merchant_name
     *
     * @return string|null
     */
    public function getPspClientMerchantName()
    {
        return $this->container['psp_client_merchant_name'];
    }

    /**
     * Sets psp_client_merchant_name
     *
     * @param string|null $psp_client_merchant_name Nombre del comercio final para quien un proveedor de servicios de pago procesa un pago. Requerido para transacciones de clientes PSP; no aplicable para otros. En caso de tratarse de un PSP de PSP, estos deben ingresarse separados por '->'.
     *
     * @return self
     */
    public function setPspClientMerchantName($psp_client_merchant_name)
    {
        if (is_null($psp_client_merchant_name)) {
            throw new \InvalidArgumentException('non-nullable psp_client_merchant_name cannot be null');
        }
        if ((mb_strlen($psp_client_merchant_name) > 255)) {
            throw new \InvalidArgumentException('invalid length for $psp_client_merchant_name when calling PaymentPostPayment., must be smaller than or equal to 255.');
        }
        if ((mb_strlen($psp_client_merchant_name) < 3)) {
            throw new \InvalidArgumentException('invalid length for $psp_client_merchant_name when calling PaymentPostPayment., must be bigger than or equal to 3.');
        }

        $this->container['psp_client_merchant_name'] = $psp_client_merchant_name;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


